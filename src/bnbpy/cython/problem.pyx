from libcpp cimport bool

import copy

from bnbpy.cython.solution cimport Solution
from bnbpy.cython.status cimport OptStatus


cdef class Problem:
    """
    Abstraction for an optimization problem

    IMPORTANT: Always remember to implement the methods:
        - `calc_bound`
        - `is_feasible`
        - `branch`

    Although not implemented using an abstract base class,
    due to Cython limitations, these methods are essential for the
    correct functioning of the branch-and-bound algorithm.

    The method `warmstart` is optional,
    but it can be used to provide a warmstart solution.

    Note that the Cython implementation uses static typing,
    so the `solution` attribute class must be a subclass of
    `bnbpy.cython.solution.Solution`.
    """

    def __init__(self) -> None:
        self.solution = Solution()

    def __del__(self):
        self.cleanup()

    @property
    def lb(self):
        return self.get_lb()

    cpdef void cleanup(Problem self):
        self.solution = None

    cpdef double calc_bound(Problem self):
        """
        Returns a lower bound of the (sub)problem. By default,
        the subproblems' nodes are initialized with the same lower bounds
        as the parent problems' nodes.

        Returns
        -------
        float
            Lower bound of the (sub)problem
        """
        raise NotImplementedError("Must implement `calc_bound` method")

    cpdef void compute_bound(Problem self):
        lb = self.calc_bound()
        self.solution.set_lb(lb)

    cpdef bool is_feasible(Problem self):
        """
        Returns `True` if the problem in its complete
        form has a feasible solution.

        It is called after a new node is selected for evaluation
        from the active queue, if its lower bound is better than
        the best solution found so far, and before branching.

        Returns
        -------
        bool
            Feasibility check
        """
        raise NotImplementedError("Must implement `is_feasible` method")

    cpdef list[Problem] branch(Problem self):
        """Generates child nodes (problems) by branching.

        Be careful not to modify attributes shared among nodes.
        It is also recommended to avoid performing expensive copy
        operations, by only modifying the attributes
        that differ between nodes.

        Returns
        -------
        Sequence[Problem]
            Sequence of child nodes problems generated by branching
        """
        raise NotImplementedError("Must implement `branch` method")

    cpdef bool check_feasible(Problem self):
        cdef:
            bool feas
        feas = self.is_feasible()
        if feas:
            self.solution.set_feasible()
        else:
            self.solution.set_infeasible()
        return feas

    cpdef void set_solution(Problem self, Solution solution):
        self.solution = solution
        if self.solution.status == OptStatus.NO_SOLUTION:
            self.compute_bound()

    cpdef Problem warmstart(Problem self):
        """Placeholder for warmstart implementation.
        If the problem has a warmstart function that returns a feasible
        problem state, it will be used at the begining of the search tree.

        Be careful not to modify the current problem instance,
        but return a new one.

        Returns
        -------
        Optional[Problem]
            Problem modified in a warmstart form, or None
            (in case not implemented)
        """
        return None

    cpdef Problem copy(self, bool deep=True):
        if deep:
            return self.deep_copy()
        return self.shallow_copy()
